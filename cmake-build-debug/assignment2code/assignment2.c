/* recognizeExp.c, Gerard Renardel, 29 January 2014
 *
 * In this file a recognizer acceptExpression is definined that can recognize
 * arithmetical expressions generated by the following BNF grammar:
 *
 * <expression>  ::= <term> { '+'  <term> | '-' <term> }
 *
 * <term>       ::= <factor> { '*' <factor> | '/' <factor> }
 *
 * <factor>     ::= <number> | <identifier> | '(' <expression> ')'
 *
 * Input for the recognizer is the token list constructed by the scanner (in scanner.c).
 * For the recognition of a token list the method of *recursive descent* is used.
 * It relies on the use of three functions for the recognition and processing of
 * terms, factors and expressions, respectively.
 * These three functions are defined with mutual recursion, corresponding with the
 * structure of the BNF grammar.
 *
 *
 *
 *
 */

#include <stdio.h>  /* getchar, printf */
#include <stdlib.h> /* NULL */
//#include "LibList.h"
#include "scanner.h"
//#include "recognizeExp.c"

int acceptNumber2(List *lp);

int acceptIdentifier2(List *lp);

int acceptCharacter2(List *lp, char c);

int acceptExpression2(List *lp);

int acceptTerm2(List *lp);

int acceptEquation2(List *lp);

//void recognizeEquation();


/* The functions acceptNumber, acceptIdentifier and acceptCharacter have as
 * (first) argument a pointer to an token list; moreover acceptCharacter has as
 * second argument a character. They check whether the first token
 * in the list is a number, an identifier or the given character, respectively.
 * When that is the case, they yield the value 1 and the pointer points to the rest of
 * the token list. Otherwise they yield 0 and the pointer remains unchanged.
 */

int acceptNumber2(List *lp) {
    if (*lp != NULL && (*lp)->tt == Number) {
        *lp = (*lp)->next;
        return 1;
    }
    return 0;
}

// store identifiers in identifierList
int acceptIdentifier2(List *lp) {
    if (*lp != NULL && (*lp)->tt == Identifier) {
        printf("\n identifier = \t %s \n", (*lp)->t.identifier);

        *lp = (*lp)->next;
        return 1;
    }
    return 0;
}

int acceptCharacter2(List *lp, char c) {
    if (*lp != NULL && (*lp)->tt == Symbol && ((*lp)->t).symbol == c) {
        *lp = (*lp)->next;
        return 1;
    }
    return 0;
}

// store the successor of ^ in powerList
int acceptDegree2(List *lp) {
    if (*lp != NULL && (*lp)->tt == Number) {
        printf("\n power = \t\t %d \n", (*lp)->t.number);

        *lp = (*lp)->next;
        return 1;
    }
    return 0;
}

/* The functions acceptFactor, acceptTerm and acceptExpression have as
 * argument a pointer to a token list. They check whether the token list
 * has an initial segment that can be recognized as factor, term or expression, respectively.
 * When that is the case, they yield the value 1 and the pointer points to the rest of
 * the token list. Otherwise they yield 0 and the pointer remains unchanged.
 */

// <term> ::= <nat> | [ <nat> ] <identifier> [ ‘^’ <nat> ]
int acceptTerm2(List *lp) {
    if (acceptIdentifier2(lp)) {
        if (acceptCharacter2(lp, '^')) {
            if (acceptDegree2(lp)) {
                return 1;
            }
            return 0;
        }
        return 1;
    }
    if (acceptNumber2(lp)) {
        if (acceptIdentifier2(lp)) {
            if (acceptCharacter2(lp, '^')) {
                if (acceptDegree2(lp)) {
                    return 1;
                }
                return 0;
            }
            return 1;
        }
        return 1;
    }
    return 0;
}

// <expression> ::= [ ‘–’ ] <term> { ‘+’ <term> | ‘–’ <term> } .
int acceptExpression2(List *lp) {
    if (acceptTerm2(lp)) {
        while (acceptCharacter2(lp, '+') || acceptCharacter2(lp, '-')) {
            if (!acceptTerm2(lp)) {
                return 0;
            }
        } /* no + or -, so we reached the end of the expression */
        return 1;
    } else if (acceptCharacter2(lp, '-')) {
        return acceptExpression2(lp);
    }
    return 0;
}

// <equation> ::= <expression> ‘=’ <expression> .
int acceptEquation2(List *lp) {
    if (acceptExpression2(lp) && acceptCharacter2(lp, '=') && acceptExpression2(lp)) {
        return 1;
    }
    return 0;
}

// checks if identifiers in identifierList are the same
int identifierChecker2(){
    return 1;
}

// if identifiers are the same, get highest value from powerList
int degreeChecker2() {
    int degree = 9;
    if(identifierChecker2() == 1) {
        return degree;
    }
    return 0;
}

/* The function recognizeEquations demonstrates the recognizer. */
void recognizeEquations2() {
    char *ar;
    List tl, tl1;
    printf("give an equation: ");
    ar = readInput();
    while (ar[0] != '!') {
        tl = tokenList(ar);
        printf("the token list is ");
        printList(tl);
        tl1 = tl;
        if (acceptEquation2(&tl1) && tl1 == NULL) {
            printf("this is an equation");
            if(degreeChecker2() == 0){
                printf(", but not in 1 variable");
            }else{
                printf(" in 1 variable of degree %d", degreeChecker2());
            }
        } else {
            printf("this is not an equation\n");
        }
        free(ar);
        freeTokenList(tl);
        printf("\ngive an equation: ");
        ar = readInput();
    }
    free(ar);
    printf("good bye\n");
}


int main(int argc, char *argv[]) {
    recognizeEquations2();
    //recognizeTerms();
    return 0;
}
